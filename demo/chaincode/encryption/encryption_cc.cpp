#include "shim.h"
#include "logging.h"
#include <string>
#include <ctime>
#include <stdio.h>
#include <cstdlib>
#include <math.h>
#include <random>

#define OK "OK"
#define NOT_FOUND "Bid not found"

#define MAX_VALUE_SIZE 1024
double encryption_key;
double encrypted_object;

//  Add bid_name, value to ledger
std::string storeBid(std::string bid_name, int value, shim_ctx_ptr_t ctx)
{
    LOG_DEBUG("+++ storeBid:  +++");
    //The number below must be generated by a random number generator
    encryption_key = 298347%100;

    //Decryption key is only known to the user. Here it is symmetric. But should be assymmetric. 
    double decryption_key = encryption_key;

    // Encryption
    encrypted_object = value*encryption_key;

    //Store on the ledger
    put_state(bid_name.c_str(), (uint8_t*)&encrypted_object, sizeof(encrypted_object), ctx);

    return std::to_string(decryption_key);
}

std::string retrieveBid(std::string bid_name, double decryption_key, shim_ctx_ptr_t ctx)
{
    std::string result;
    LOG_DEBUG(" +++ retrieveBid +++");

    uint32_t bid_bytes_len = -1;
    //Retrieve the encrypted object from the ledger
    get_state(bid_name.c_str(), (uint8_t*)&encrypted_object, sizeof(encrypted_object), &bid_bytes_len, ctx);

    //  If decryption key matches the encryption key
    if (decryption_key/encryption_key == 1)
    {
	double decrypted_value = encrypted_object/decryption_key;
        result = bid_name +   std::to_string(decrypted_value);
     } else {
        //  bid does not exist
        result = NOT_FOUND;
    }
    return result;
}

// implements chaincode logic for invoke
int invoke(
    uint8_t* response,
    uint32_t max_response_len,
    uint32_t* actual_response_len,
    shim_ctx_ptr_t ctx)
{
    //LOG_DEBUG("HelloworldCC: +++ Executing helloworld chaincode invocation +++");

    std::string function_name;
    std::vector<std::string> params;
    get_func_and_params(function_name, params, ctx);
    std::string bid_name = params[0];
    std::string result;

    if (function_name == "storeBid")
    {
        int value = std::stoi (params[1]);
        result = storeBid(bid_name, value, ctx);
    }
    else if (function_name == "retrieveBid")
    {
        double decryption_key = std::stod (params[1]);
        result = retrieveBid(bid_name, decryption_key, ctx);
    }
    else
    {
        // unknown function
        LOG_DEBUG("HelloworldCC: RECEIVED UNKNOWN transaction '%s'", function_name);
        return -1;
    }

    // check that result fits into response
    int neededSize = result.size();
    if (max_response_len < neededSize)
    {
        // error:  buffer too small for the response to be sent
        *actual_response_len = 0;
        return -1;
    }

    // copy result to response
    memcpy(response, result.c_str(), neededSize);
    *actual_response_len = neededSize;
    LOG_DEBUG("HelloworldCC: Response: %s", result.c_str());
    LOG_DEBUG("HelloworldCC: +++ Executing done +++");
    return 0;
}
